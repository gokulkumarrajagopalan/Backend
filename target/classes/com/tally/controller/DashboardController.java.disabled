package com.tally.controller;

import com.tally.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/dashboard")
public class DashboardController {
    @Autowired
    private CompanyRepository companyRepository;
    
    @Autowired
    private AccountMasterRepository accountMasterRepository;
    
    @Autowired
    private PartyRepository partyRepository;
    
    @Autowired
    private JournalEntryRepository journalEntryRepository;
    
    @Autowired
    private InvoiceRepository invoiceRepository;
    
    @Autowired
    private InventoryItemRepository inventoryItemRepository;

    @GetMapping("/company/{companyId}/metrics")
    public ResponseEntity<Map<String, Object>> getCompanyMetrics(@PathVariable Long companyId) {
        try {
            Map<String, Object> metrics = new HashMap<>();
            
            // Company info
            var company = companyRepository.findById(companyId);
            metrics.put("companyName", company.map(c -> c.getName()).orElse("N/A"));
            
            // Account metrics
            var accounts = accountMasterRepository.findByCompanyId(companyId);
            metrics.put("totalAccounts", accounts.size());
            metrics.put("activeAccounts", accounts.stream().filter(a -> a.getActive()).count());
            
            Double totalBalance = accounts.stream()
                .mapToDouble(a -> a.getCurrentBalance() != null ? a.getCurrentBalance() : 0)
                .sum();
            metrics.put("totalAccountBalance", totalBalance);
            
            // Party metrics
            var parties = partyRepository.findByCompanyId(companyId);
            metrics.put("totalParties", parties.size());
            metrics.put("totalCustomers", parties.stream().filter(p -> "CUSTOMER".equals(p.getPartyType())).count());
            metrics.put("totalSuppliers", parties.stream().filter(p -> "SUPPLIER".equals(p.getPartyType())).count());
            
            // Transaction metrics
            var transactions = journalEntryRepository.findByCompanyId(companyId);
            metrics.put("totalTransactions", transactions.size());
            metrics.put("postedTransactions", transactions.stream().filter(t -> "POSTED".equals(t.getStatus())).count());
            metrics.put("draftTransactions", transactions.stream().filter(t -> "DRAFT".equals(t.getStatus())).count());
            
            // Invoice metrics
            var invoices = invoiceRepository.findByCompanyId(companyId);
            metrics.put("totalInvoices", invoices.size());
            metrics.put("paidInvoices", invoices.stream().filter(i -> "PAID".equals(i.getStatus())).count());
            metrics.put("overdueInvoices", invoices.stream().filter(i -> "OVERDUE".equals(i.getStatus())).count());
            
            Double invoiceTotal = invoices.stream()
                .mapToDouble(i -> i.getTotalAmount() != null ? i.getTotalAmount() : 0)
                .sum();
            metrics.put("totalInvoiceAmount", invoiceTotal);
            
            // Inventory metrics
            var items = inventoryItemRepository.findByCompanyIdAndActiveTrue(companyId);
            metrics.put("totalInventoryItems", items.size());
            metrics.put("lowStockItems", items.stream().filter(i -> i.getQuantity() < (i.getReorderLevel() != null ? i.getReorderLevel() : 10)).count());
            
            Double inventoryValue = items.stream()
                .mapToDouble(i -> i.getCurrentValue() != null ? i.getCurrentValue() : 0)
                .sum();
            metrics.put("totalInventoryValue", inventoryValue);
            
            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("data", metrics);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", e.getMessage());
            return ResponseEntity.status(400).body(response);
        }
    }

    @GetMapping("/company/{companyId}/account-summary")
    public ResponseEntity<Map<String, Object>> getAccountSummary(@PathVariable Long companyId) {
        try {
            var accounts = accountMasterRepository.findByCompanyId(companyId);
            
            Map<String, Object> summary = new HashMap<>();
            
            Double assets = accounts.stream()
                .filter(a -> "Asset".equals(a.getAccountType()))
                .mapToDouble(a -> a.getCurrentBalance() != null ? a.getCurrentBalance() : 0)
                .sum();
            
            Double liabilities = accounts.stream()
                .filter(a -> "Liability".equals(a.getAccountType()))
                .mapToDouble(a -> a.getCurrentBalance() != null ? a.getCurrentBalance() : 0)
                .sum();
            
            Double capital = accounts.stream()
                .filter(a -> "Capital".equals(a.getAccountType()))
                .mapToDouble(a -> a.getCurrentBalance() != null ? a.getCurrentBalance() : 0)
                .sum();
            
            Double income = accounts.stream()
                .filter(a -> "Income".equals(a.getAccountType()))
                .mapToDouble(a -> a.getCurrentBalance() != null ? a.getCurrentBalance() : 0)
                .sum();
            
            Double expense = accounts.stream()
                .filter(a -> "Expense".equals(a.getAccountType()))
                .mapToDouble(a -> a.getCurrentBalance() != null ? a.getCurrentBalance() : 0)
                .sum();
            
            summary.put("assets", assets);
            summary.put("liabilities", liabilities);
            summary.put("capital", capital);
            summary.put("income", income);
            summary.put("expense", expense);
            summary.put("netProfit", income - expense);
            
            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("data", summary);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", e.getMessage());
            return ResponseEntity.status(400).body(response);
        }
    }
}
